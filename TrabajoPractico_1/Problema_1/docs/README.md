# 📝Documentación del proyecto
El código implementado compara la eficiencia de algoritmos de ordenamiento midiendo sus tiempos de ejecución con listas de diferentes tamaños y visualizando los resultados mediante matplotlib, una librería estándar de Python especializada en visualización de datos. Esta herramienta permite crear gráficos profesionales con configuración personalizada de ejes, leyendas y estilos, siendo ideal para análisis comparativos como este.

Burbuja (línea roja) destaca como el menos eficiente, mostrando un crecimiento cuadrático (O(n²)) en su tiempo de ejecución. Su utilidad se limita a listas pequeñas o contextos educativos, ya que su rendimiento colapsa rápidamente con más elementos. Quicksort (línea azul) ofrece un equilibrio óptimo entre complejidad y velocidad, con un comportamiento promedio de O(n log n). Aunque en casos extremos (p.ej., pivotes desbalanceados) puede degradarse a O(n²), su enfoque recursivo lo hace confiable para listas grandes. Radix Sort (línea verde) brilla con un tiempo casi lineal (O(n)) en este escenario, al evitar comparaciones directas y ordenar dígito por dígito. Sin embargo, su aplicación está restringida a datos numéricos con formato predefinido, como los números de 5 cifras usados aquí.

La función sorted() de Python (línea morada), basada en Timsort, combina Merge Sort e Insertion Sort para lograr eficiencia adaptativa (O(n log n)). Detecta secuencias parcialmente ordenadas, optimizando el proceso para datos reales. Matplotlib facilita esta comparación mediante gráficos claros y personalizables, como el generado en el proyecto, que muestra líneas diferenciadas por color y una cuadrícula para interpretar fácilmente las diferencias de rendimiento.

La elección del algoritmo depende del contexto: Quicksort o sorted() son ideales para listas genéricas grandes, Radix Sort es imbatible con números de dígitos fijos, y Burbuja sirve principalmente para aprendizaje. La gráfica, creada con matplotlib, refleja estas diferencias y subraya la importancia de seleccionar métodos adecuados según el tipo y tamaño de los datos.
