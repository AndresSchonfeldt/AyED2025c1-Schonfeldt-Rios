# 📝Documentación del proyecto
El código implementado permite comparar la eficiencia de varios algoritmos de ordenamiento midiendo sus tiempos de ejecución con listas de diferentes tamaños y visualizando los resultados en una gráfica. Esto ayuda a entender cómo se comporta cada algoritmo según la cantidad de datos.
Burbuja (línea roja) es el menos eficiente, mostrando un aumento rápido y cuadrático (O(n²)) en su tiempo de ejecución. Esto lo hace útil sólo para listas pequeñas o como ejemplo educativo, ya que su rendimiento se deteriora notablemente con más elementos.
Quicksort (línea azul) ofrece un mejor equilibrio, con un comportamiento promedio cercano a O(n log n). Aunque en casos extremos (pivotes desbalanceados) puede degradarse a O(n²), en la práctica suele ser rápido y confiable para listas grandes, gracias a su enfoque recursivo de "dividir y conquistar".
Radix Sort (línea verde) es el más eficiente en este escenario, con un tiempo casi lineal (O(n)), ya que evita comparaciones directas y ordena dígito por dígito. Sin embargo, su aplicación está limitada a datos numéricos con dígitos predefinidos, como los números de 5 cifras usados en el código.
La función sorted () de Python (línea morada), que utiliza Timsort, combina lo mejor de Merge Sort e Insertion Sort. Es altamente eficiente (O(n log n)) y adaptativo, detectando patrones en los datos (como secuencias parcialmente ordenadas) para optimizar el proceso. Esto lo hace ideal para datos del mundo real, donde es común encontrar información con cierto orden preexistente.
 La elección del algoritmo depende del contexto: Quicksort o sorted() son ideales para listas genéricas grandes, Radix Sort es imbatible con números de dígitos fijos, y Burbuja sirve principalmente para aprendizaje. La gráfica generada refleja claramente estas diferencias, destacando la importancia de seleccionar el método adecuado según el tipo y tamaño de los datos.
