# 游닇Documentaci칩n del proyecto
El c칩digo implementado permite comparar la eficiencia de varios algoritmos de ordenamiento midiendo sus tiempos de ejecuci칩n con listas de diferentes tama침os y visualizando los resultados en una gr치fica. Esto ayuda a entender c칩mo se comporta cada algoritmo seg칰n la cantidad de datos.
Burbuja (l칤nea roja) es el menos eficiente, mostrando un aumento r치pido y cuadr치tico (O(n)) en su tiempo de ejecuci칩n. Esto lo hace 칰til s칩lo para listas peque침as o como ejemplo educativo, ya que su rendimiento se deteriora notablemente con m치s elementos.
Quicksort (l칤nea azul) ofrece un mejor equilibrio, con un comportamiento promedio cercano a O(n log n). Aunque en casos extremos (pivotes desbalanceados) puede degradarse a O(n), en la pr치ctica suele ser r치pido y confiable para listas grandes, gracias a su enfoque recursivo de "dividir y conquistar".
Radix Sort (l칤nea verde) es el m치s eficiente en este escenario, con un tiempo casi lineal (O(n)), ya que evita comparaciones directas y ordena d칤gito por d칤gito. Sin embargo, su aplicaci칩n est치 limitada a datos num칠ricos con d칤gitos predefinidos, como los n칰meros de 5 cifras usados en el c칩digo.
La funci칩n sorted () de Python (l칤nea morada), que utiliza Timsort, combina lo mejor de Merge Sort e Insertion Sort. Es altamente eficiente (O(n log n)) y adaptativo, detectando patrones en los datos (como secuencias parcialmente ordenadas) para optimizar el proceso. Esto lo hace ideal para datos del mundo real, donde es com칰n encontrar informaci칩n con cierto orden preexistente.
 La elecci칩n del algoritmo depende del contexto: Quicksort o sorted() son ideales para listas gen칠ricas grandes, Radix Sort es imbatible con n칰meros de d칤gitos fijos, y Burbuja sirve principalmente para aprendizaje. La gr치fica generada refleja claramente estas diferencias, destacando la importancia de seleccionar el m칠todo adecuado seg칰n el tipo y tama침o de los datos.
